#######################################################################################
# File:             tracker_client_handler.py
# Author:           Calvin Tam
# Purpose:          CSC645 Assigment #2 P2P Decentralized Network with BitTorrent Protocol
# Description:      Template ClientHandler class. You are free to modify this
#                   file to meet your own needs. Additionally, you are
#                   free to drop this client handler class, and use a version of yours instead.
# Running:          This class is dependent of other classes.
# Usage :           tracker_client_handler = TrackerClientHandler() # creates object
########################################################################################

import sys
import re

from client_handler import ClientHandler


class TrackerClientHandler(ClientHandler):
    def __init__(self, ready, server_instance, clientsocket, addr):
        # inherit from base class
        super().__init__(ready, server_instance, clientsocket, addr)

    def run(self):
        # print client connected message
        print("[" + self.server.id_key + " SERVER] Client \"" + str(self.client_id) + "\" connected.")
        try:
            while True:
                # handle closed pipe
                if self.clientsocket.fileno() == -1:
                    raise
                # waiting for response
                while self.process():
                    continue
        except BrokenPipeError:
            # handle broken pipe
            pass
        except:
            # handle other exceptions
            print("Failed at running at client thread: ", sys.exc_info()[0])
            raise
        # remove users from server client list
        self.delete_client_data()
        # print client disconnected message
        print("[" + self.server.id_key + " SERVER] Client \"" + str(self.client_id) + "\" disconnected.")

    def process(self):
        """
        Process input
        """
        data = self.server.receive(self.clientsocket)
        # check for disconnected socket
        if not data:
            return None
        # check if this is a valid HTTP request on THP
        if re.fullmatch(b'GET \/(\?[\w\_]+\=[\w\d]+){1}(\&[\w\_]+\=[\w\d-]+){4} HTTP\/(\d.\d)\r\nHost: [\w\d.]+(:[\d]{1,5}){1}\r\nUser-Agent: [\w\d-]+\r\nAccept-Encoding: gzip\r\nConnection: Close', data):
            (info_hash, peer_id, uploaded, downloaded, left, peer_ip, peer_port) = self.server.thp.parse_request(data)
            # validate info_hash for this tracker server
            if not self.validate_torrent_info_hash(info_hash):
                print("[" + self.server.id_key + " SERVER] Torrent info hash not matched at tracker server. Disconecting")
                return False
            # add peer to swarm if not exists
            if not peer_id in self.server.swarm:
                self.server.add_peer_to_swarm(peer_id, peer_ip, peer_port)
            # update peer info in swarm
            if not self.server.update_peer_in_swarm(peer_id, uploaded, downloaded, left):
                print("[" + self.server.id_key + " SERVER] Failed to update peer " + peer_id + " info as it does not exist in swarm")
            self.server.broadcast()
        else:
            print("[" + self.server.id_key + " SERVER] Unsupported message")
        return True

    def validate_torrent_info_hash(self, peer_torrent_info_hash):
        """
        compare the info_hash generated by this peer with another info_hash sent by another peer
        this is done to make sure that both peers agree to share the same file.
        :param peer_torrent_info_hash: the info_hash from the info section of the torrent sent by other peer
        :return: True if the info_hashes are equal. Otherwise, returns false.
        """
        return self.server.torrent_info_hash == peer_torrent_info_hash
